// Code generated by github.com/zchee/go-openapi-tools/cmd/oapi-generator. DO NOT EDIT.

package togetherai

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strconv"
	"strings"
)

// Always reference these packages, just in case the auto-generated code below doesn't.
var (
	_ = bytes.NewBuffer
	_ = context.Canceled
	_ = json.NewDecoder
	_ = errors.New
	_ = fmt.Sprintf
	_ = io.Copy
	_ = http.NewRequest
	_ = url.Parse
	_ = strconv.Itoa
	_ = path.Join
	_ = strings.Replace
	_ = gzip.NewReader
)

type DefaultService struct {
	s *Service
}

// NewDefault returns the new Default.
func NewDefaultService(s *Service) *DefaultService {
	rs := &DefaultService{s: s}
	return rs
}

// DefaultServiceAudioSpeechCall provides the create audio generation request.
type DefaultServiceAudioSpeechCall struct {
	s      *Service
	header http.Header
	params url.Values
}

type DefaultServiceAudioSpeechCallResponse struct{}

// AudioSpeech returns the DefaultServiceAudioSpeechCall for create audio generation request.
func (r *DefaultService) AudioSpeech() *DefaultServiceAudioSpeechCall {
	c := &DefaultServiceAudioSpeechCall{
		s:      r.s,
		header: make(http.Header),
		params: url.Values{},
	}
	return c
}

// Do executes the DefaultServiceAudioSpeech.
func (c *DefaultServiceAudioSpeechCall) Do(ctx context.Context) (*DefaultServiceAudioSpeechCallResponse, error) {
	uri := path.Join(c.s.BasePath, "/audio/speech")
	if len(c.params) > 0 {
		uri += "?" + c.params.Encode()
	}

	req, err := http.NewRequestWithContext(ctx, http.MethodPost, uri, nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "application/json")

	resp, err := c.s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return nil, errors.New(resp.Status)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var result DefaultServiceAudioSpeechCallResponse
	if err := json.Unmarshal(body, &result); err != nil {
		return nil, err
	}

	return &result, nil
}

// DefaultServiceChatCompletionsCall provides the create chat completion.
type DefaultServiceChatCompletionsCall struct {
	s      *Service
	header http.Header
	params url.Values
}

type DefaultServiceChatCompletionsCallResponse struct{}

// ChatCompletions returns the DefaultServiceChatCompletionsCall for create chat completion.
func (r *DefaultService) ChatCompletions() *DefaultServiceChatCompletionsCall {
	c := &DefaultServiceChatCompletionsCall{
		s:      r.s,
		header: make(http.Header),
		params: url.Values{},
	}
	return c
}

// Do executes the DefaultServiceChatCompletions.
func (c *DefaultServiceChatCompletionsCall) Do(ctx context.Context) (*DefaultServiceChatCompletionsCallResponse, error) {
	uri := path.Join(c.s.BasePath, "/chat/completions")
	if len(c.params) > 0 {
		uri += "?" + c.params.Encode()
	}

	req, err := http.NewRequestWithContext(ctx, http.MethodPost, uri, nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "application/json")

	resp, err := c.s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return nil, errors.New(resp.Status)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var result DefaultServiceChatCompletionsCallResponse
	if err := json.Unmarshal(body, &result); err != nil {
		return nil, err
	}

	return &result, nil
}

// DefaultServiceCompletionsCall provides the create completion.
type DefaultServiceCompletionsCall struct {
	s      *Service
	header http.Header
	params url.Values
}

type DefaultServiceCompletionsCallResponse struct{}

// Completions returns the DefaultServiceCompletionsCall for create completion.
func (r *DefaultService) Completions() *DefaultServiceCompletionsCall {
	c := &DefaultServiceCompletionsCall{
		s:      r.s,
		header: make(http.Header),
		params: url.Values{},
	}
	return c
}

// Do executes the DefaultServiceCompletions.
func (c *DefaultServiceCompletionsCall) Do(ctx context.Context) (*DefaultServiceCompletionsCallResponse, error) {
	uri := path.Join(c.s.BasePath, "/completions")
	if len(c.params) > 0 {
		uri += "?" + c.params.Encode()
	}

	req, err := http.NewRequestWithContext(ctx, http.MethodPost, uri, nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "application/json")

	resp, err := c.s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return nil, errors.New(resp.Status)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var result DefaultServiceCompletionsCallResponse
	if err := json.Unmarshal(body, &result); err != nil {
		return nil, err
	}

	return &result, nil
}

// DefaultServiceEmbeddingsCall provides the create embedding.
type DefaultServiceEmbeddingsCall struct {
	s      *Service
	header http.Header
	params url.Values
}

type DefaultServiceEmbeddingsCallResponse struct{}

// Embeddings returns the DefaultServiceEmbeddingsCall for create embedding.
func (r *DefaultService) Embeddings() *DefaultServiceEmbeddingsCall {
	c := &DefaultServiceEmbeddingsCall{
		s:      r.s,
		header: make(http.Header),
		params: url.Values{},
	}
	return c
}

// Do executes the DefaultServiceEmbeddings.
func (c *DefaultServiceEmbeddingsCall) Do(ctx context.Context) (*DefaultServiceEmbeddingsCallResponse, error) {
	uri := path.Join(c.s.BasePath, "/embeddings")
	if len(c.params) > 0 {
		uri += "?" + c.params.Encode()
	}

	req, err := http.NewRequestWithContext(ctx, http.MethodPost, uri, nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "application/json")

	resp, err := c.s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return nil, errors.New(resp.Status)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var result DefaultServiceEmbeddingsCallResponse
	if err := json.Unmarshal(body, &result); err != nil {
		return nil, err
	}

	return &result, nil
}

// DefaultServiceListEndpointsCall provides the list all endpoints, can be filtered by type.
type DefaultServiceListEndpointsCall struct {
	s      *Service
	header http.Header
	params url.Values

	// query fields
	typ string
}

type DefaultServiceListEndpointsCallResponse struct {
	Data   any    `json:"data"`
	Object string `json:"object"`
}

// ListEndpoints returns the DefaultServiceListEndpointsCall for list all endpoints, can be filtered by type.
func (r *DefaultService) ListEndpoints() *DefaultServiceListEndpointsCall {
	c := &DefaultServiceListEndpointsCall{
		s:      r.s,
		header: make(http.Header),
		params: url.Values{},
	}
	return c
}

func (c *DefaultServiceListEndpointsCall) Type(typ string) *DefaultServiceListEndpointsCall {
	c.params.Set("typ", fmt.Sprintf("%s", typ))
	return c
}

// Do executes the DefaultServiceListEndpoints.
func (c *DefaultServiceListEndpointsCall) Do(ctx context.Context) (*DefaultServiceListEndpointsCallResponse, error) {
	uri := path.Join(c.s.BasePath, "/endpoints")
	if len(c.params) > 0 {
		uri += "?" + c.params.Encode()
	}

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, uri, nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "application/json")

	resp, err := c.s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return nil, errors.New(resp.Status)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var result DefaultServiceListEndpointsCallResponse
	if err := json.Unmarshal(body, &result); err != nil {
		return nil, err
	}

	return &result, nil
}

// DefaultServiceCreateEndpointCall provides the create a dedicated endpoint, it will start automatically.
type DefaultServiceCreateEndpointCall struct {
	s      *Service
	header http.Header
	params url.Values
}

type DefaultServiceCreateEndpointCallResponse struct{}

// CreateEndpoint returns the DefaultServiceCreateEndpointCall for create a dedicated endpoint, it will start automatically.
func (r *DefaultService) CreateEndpoint() *DefaultServiceCreateEndpointCall {
	c := &DefaultServiceCreateEndpointCall{
		s:      r.s,
		header: make(http.Header),
		params: url.Values{},
	}
	return c
}

// Do executes the DefaultServiceCreateEndpoint.
func (c *DefaultServiceCreateEndpointCall) Do(ctx context.Context) (*DefaultServiceCreateEndpointCallResponse, error) {
	uri := path.Join(c.s.BasePath, "/endpoints")
	if len(c.params) > 0 {
		uri += "?" + c.params.Encode()
	}

	req, err := http.NewRequestWithContext(ctx, http.MethodPost, uri, nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "application/json")

	resp, err := c.s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return nil, errors.New(resp.Status)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var result DefaultServiceCreateEndpointCallResponse
	if err := json.Unmarshal(body, &result); err != nil {
		return nil, err
	}

	return &result, nil
}

// DefaultServiceDeleteEndpointCall provides the delete endpoint.
type DefaultServiceDeleteEndpointCall struct {
	s      *Service
	header http.Header
	params url.Values

	// path fields
	endpointID string
}

// DeleteEndpoint returns the DefaultServiceDeleteEndpointCall for delete endpoint.
func (r *DefaultService) DeleteEndpoint(endpointID string) *DefaultServiceDeleteEndpointCall {
	c := &DefaultServiceDeleteEndpointCall{
		s:          r.s,
		header:     make(http.Header),
		params:     url.Values{},
		endpointID: endpointID,
	}
	return c
}

// Do executes the DefaultServiceDeleteEndpoint.
func (c *DefaultServiceDeleteEndpointCall) Do(ctx context.Context) (any, error) {
	uri := path.Join(c.s.BasePath, "/endpoints/"+fmt.Sprintf("%s", c.endpointID)+"")
	if len(c.params) > 0 {
		uri += "?" + c.params.Encode()
	}

	req, err := http.NewRequestWithContext(ctx, http.MethodDelete, uri, nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "application/json")

	resp, err := c.s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return nil, errors.New(resp.Status)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var result any
	if err := json.Unmarshal(body, &result); err != nil {
		return nil, err
	}

	return &result, nil
}

// DefaultServiceCall provides the list all files.
type DefaultServiceCall struct {
	s      *Service
	header http.Header
	params url.Values
}

type DefaultServiceCallResponse struct{}

//	returns the DefaultServiceCall for list all files.
//
// DefaultServiceListHardwareCall provides the list available hardware configurations.
type DefaultServiceListHardwareCall struct {
	s      *Service
	header http.Header
	params url.Values

	// query fields
	model string
}

type DefaultServiceListHardwareCallResponse struct {
	Data   any    `json:"data"`
	Object string `json:"object"`
}

// ListHardware returns the DefaultServiceListHardwareCall for list available hardware configurations.
func (r *DefaultService) ListHardware() *DefaultServiceListHardwareCall {
	c := &DefaultServiceListHardwareCall{
		s:      r.s,
		header: make(http.Header),
		params: url.Values{},
	}
	return c
}

func (c *DefaultServiceListHardwareCall) Model(model string) *DefaultServiceListHardwareCall {
	c.params.Set("model", fmt.Sprintf("%s", model))
	return c
}

// Do executes the DefaultServiceListHardware.
func (c *DefaultServiceListHardwareCall) Do(ctx context.Context) (*DefaultServiceListHardwareCallResponse, error) {
	uri := path.Join(c.s.BasePath, "/hardware")
	if len(c.params) > 0 {
		uri += "?" + c.params.Encode()
	}

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, uri, nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "application/json")

	resp, err := c.s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return nil, errors.New(resp.Status)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var result DefaultServiceListHardwareCallResponse
	if err := json.Unmarshal(body, &result); err != nil {
		return nil, err
	}

	return &result, nil
}

// DefaultServiceModelsCall provides the list all models.
type DefaultServiceModelsCall struct {
	s      *Service
	header http.Header
	params url.Values
}

type DefaultServiceModelsCallResponse struct{}

// Models returns the DefaultServiceModelsCall for list all models.
func (r *DefaultService) Models() *DefaultServiceModelsCall {
	c := &DefaultServiceModelsCall{
		s:      r.s,
		header: make(http.Header),
		params: url.Values{},
	}
	return c
}

// Do executes the DefaultServiceModels.
func (c *DefaultServiceModelsCall) Do(ctx context.Context) (*DefaultServiceModelsCallResponse, error) {
	uri := path.Join(c.s.BasePath, "/models")
	if len(c.params) > 0 {
		uri += "?" + c.params.Encode()
	}

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, uri, nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "application/json")

	resp, err := c.s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return nil, errors.New(resp.Status)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var result DefaultServiceModelsCallResponse
	if err := json.Unmarshal(body, &result); err != nil {
		return nil, err
	}

	return &result, nil
}

// DefaultServiceRerankCall provides the create a rerank request.
type DefaultServiceRerankCall struct {
	s      *Service
	header http.Header
	params url.Values
}

type DefaultServiceRerankCallResponse struct{}

// Rerank returns the DefaultServiceRerankCall for create a rerank request.
func (r *DefaultService) Rerank() *DefaultServiceRerankCall {
	c := &DefaultServiceRerankCall{
		s:      r.s,
		header: make(http.Header),
		params: url.Values{},
	}
	return c
}

// Do executes the DefaultServiceRerank.
func (c *DefaultServiceRerankCall) Do(ctx context.Context) (*DefaultServiceRerankCallResponse, error) {
	uri := path.Join(c.s.BasePath, "/rerank")
	if len(c.params) > 0 {
		uri += "?" + c.params.Encode()
	}

	req, err := http.NewRequestWithContext(ctx, http.MethodPost, uri, nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "application/json")

	resp, err := c.s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return nil, errors.New(resp.Status)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var result DefaultServiceRerankCallResponse
	if err := json.Unmarshal(body, &result); err != nil {
		return nil, err
	}

	return &result, nil
}
